{"version":3,"file":"main.js","sources":["webpack://my-webpack-project/./js/ts/chromedb.js","webpack://my-webpack-project/./js/ts/main.js","webpack://my-webpack-project/./node_modules/assemblyscript/lib/loader/index.js","webpack://my-webpack-project/webpack/bootstrap","webpack://my-webpack-project/webpack/runtime/define property getters","webpack://my-webpack-project/webpack/runtime/hasOwnProperty shorthand","webpack://my-webpack-project/webpack/runtime/make namespace object","webpack://my-webpack-project/webpack/startup"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ChromeDB = void 0;\r\nconst loader = require(\"../../node_modules/assemblyscript/lib/loader/index\");\r\nvar wasmIs, wasmIsnt, wasmGt, wasmLt, wasmGte, wasmLte, wasmHas;\r\nvar __getString;\r\nvar __newString;\r\nvar __getArray;\r\nvar __newArray;\r\nvar MapArray_id;\r\nconst imports = {\r\n    query: {\r\n        log: (msgPtr) => {\r\n            // at the time of call, wasmExample will be initialized\r\n            console.log('WASM is talking', __getString(msgPtr));\r\n        }\r\n    },\r\n    env: {\r\n        memory: new WebAssembly.Memory({ initial: 256 }),\r\n        table: new WebAssembly.Table({ initial: 0, element: 'anyfunc' })\r\n    }\r\n};\r\nloader.instantiate(fetch(\"query.wasm\"), imports)\r\n    .then((module) => {\r\n    wasmIs = module.exports.is;\r\n    wasmIsnt = module.exports.isnt;\r\n    wasmGt = module.exports.greaterThan;\r\n    wasmLt = module.exports.lessThan;\r\n    wasmGte = module.exports.greaterThanOrEqualTo;\r\n    wasmLte = module.exports.lessThanOrEqualTo;\r\n    wasmHas = module.exports.has;\r\n    __getString = module.exports.__getString;\r\n    __newString = module.exports.__newString;\r\n    __getArray = module.exports.__getArray;\r\n    __newArray = module.exports.__newArray;\r\n    MapArray_id = module.exports.MapArray_id;\r\n});\r\nclass Config {\r\n    constructor() {\r\n        this.documents = new Map();\r\n    }\r\n}\r\n//TODO: WASM all\r\nclass FieldCondition {\r\n    constructor(field, action) {\r\n        this.field = field;\r\n        this.action = action;\r\n    }\r\n    is(value) {\r\n        if (this.action instanceof Get) {\r\n            return new Promise((resolve, reject) => {\r\n                chrome.storage.sync.get(this.action.document, (res) => {\r\n                    if (res[this.action.document] != undefined) {\r\n                        console.log(res[this.action.document], this.field, JSON.stringify(value));\r\n                        var arrPtr = wasmIs(__newArray(MapArray_id, res[this.action.document]), __newString(this.field), __newString(JSON.stringify(value)));\r\n                        var arr = __getArray(arrPtr);\r\n                        resolve(arr);\r\n                    }\r\n                    else {\r\n                        reject(`Error finding document ${this.action.document}`);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            return this.action.where((obj) => { return obj[this.field] === value; });\r\n        }\r\n    }\r\n    isnt(value) {\r\n        if (this.action instanceof Get) {\r\n            return new Promise((resolve, reject) => {\r\n                chrome.storage.sync.get(this.action.document, (res) => {\r\n                    if (res[this.action.document] != undefined) {\r\n                        resolve(__getArray(wasmIsnt(__newArray(MapArray_id, res[this.action.document]), __newString(this.field), __newString(JSON.stringify(value)))));\r\n                    }\r\n                    else {\r\n                        reject(`Error finding document ${this.action.document}`);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            return this.action.where((obj) => { return obj[this.field] != value; });\r\n        }\r\n    }\r\n    greaterThan(value) {\r\n        if (this.action instanceof Get) {\r\n            return new Promise((resolve, reject) => {\r\n                chrome.storage.sync.get(this.action.document, (res) => {\r\n                    if (res[this.action.document] != undefined) {\r\n                        resolve(__getArray(wasmGt(__newArray(MapArray_id, res[this.action.document]), __newString(this.field), __newString(JSON.stringify(value)))));\r\n                    }\r\n                    else {\r\n                        reject(`Error finding document ${this.action.document}`);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            return this.action.where((obj) => { return obj[this.field] > value; });\r\n        }\r\n    }\r\n    lessThan(value) {\r\n        if (this.action instanceof Get) {\r\n            return new Promise((resolve, reject) => {\r\n                chrome.storage.sync.get(this.action.document, (res) => {\r\n                    if (res[this.action.document] != undefined) {\r\n                        resolve(__getArray(wasmLt(__newArray(MapArray_id, res[this.action.document]), __newString(this.field), __newString(JSON.stringify(value)))));\r\n                    }\r\n                    else {\r\n                        reject(`Error finding document ${this.action.document}`);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            return this.action.where((obj) => { return obj[this.field] < value; });\r\n        }\r\n    }\r\n    greaterThanOrEqualTo(value) {\r\n        if (this.action instanceof Get) {\r\n            return new Promise((resolve, reject) => {\r\n                chrome.storage.sync.get(this.action.document, (res) => {\r\n                    if (res[this.action.document] != undefined) {\r\n                        resolve(__getArray(wasmGte(__newArray(MapArray_id, res[this.action.document]), __newString(this.field), __newString(JSON.stringify(value)))));\r\n                    }\r\n                    else {\r\n                        reject(`Error finding document ${this.action.document}`);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            return this.action.where((obj) => { return obj[this.field] >= value; });\r\n        }\r\n    }\r\n    lessThanOrEqualTo(value) {\r\n        if (this.action instanceof Get) {\r\n            return new Promise((resolve, reject) => {\r\n                chrome.storage.sync.get(this.action.document, (res) => {\r\n                    if (res[this.action.document] != undefined) {\r\n                        resolve(__getArray(wasmLte(__newArray(MapArray_id, res[this.action.document]), __newString(this.field), __newString(JSON.stringify(value)))));\r\n                    }\r\n                    else {\r\n                        reject(`Error finding document ${this.action.document}`);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            return this.action.where((obj) => { return obj[this.field] <= value; });\r\n        }\r\n    }\r\n    isTrue() {\r\n        return this.action.where((obj) => { return obj[this.field]; });\r\n    }\r\n    isFalse() {\r\n        return this.action.where((obj) => { return obj[this.field]; });\r\n    }\r\n    has(value) {\r\n        if (this.action instanceof Get) {\r\n            return new Promise((resolve, reject) => {\r\n                chrome.storage.sync.get(this.action.document, (res) => {\r\n                    if (res[this.action.document] != undefined) {\r\n                        resolve(__getArray(wasmHas(__newArray(MapArray_id, res[this.action.document]), __newString(this.field), __newString(JSON.stringify(value)))));\r\n                    }\r\n                    else {\r\n                        reject(`Error finding document ${this.action.document}`);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            return this.action.where((obj) => { return obj[this.field].includes(value); });\r\n        }\r\n    }\r\n    length() {\r\n        return new LengthFieldCondition(this);\r\n    }\r\n}\r\nclass LengthFieldCondition extends FieldCondition {\r\n    constructor(fc) {\r\n        super(fc.field, fc.action);\r\n    }\r\n    is(value) {\r\n        return this.action.where((obj) => { return obj[this.field].length === value; });\r\n    }\r\n    isnt(value) {\r\n        return this.action.where((obj) => { return obj[this.field].length != value; });\r\n    }\r\n    greaterThan(value) {\r\n        return this.action.where((obj) => { return obj[this.field].length > value; });\r\n    }\r\n    lessThan(value) {\r\n        return this.action.where((obj) => { return obj[this.field].length < value; });\r\n    }\r\n    greaterThanOrEqualTo(value) {\r\n        return this.action.where((obj) => { return obj[this.field].length >= value; });\r\n    }\r\n    lessThanOrEqualTo(value) {\r\n        return this.action.where((obj) => { return obj[this.field].length <= value; });\r\n    }\r\n    isTrue() {\r\n        throw Error(\"You can't evaluate length as a boolean\");\r\n    }\r\n    isFalse() {\r\n        throw Error(\"You can't evaluate length as a boolean\");\r\n    }\r\n    has(value) {\r\n        throw Error(\"You can't evaluate length as an array\");\r\n    }\r\n    length() {\r\n        throw Error(\"You can't take the length of a length\");\r\n    }\r\n}\r\nclass Get {\r\n    constructor(document) { this.document = document; }\r\n    where(conditionOrField) {\r\n        if (typeof conditionOrField === \"string\") {\r\n            return new FieldCondition(conditionOrField, this);\r\n        }\r\n        else {\r\n            return new Promise((resolve, reject) => {\r\n                chrome.storage.sync.get(this.document, (res) => {\r\n                    if (res[this.document] != undefined) {\r\n                        var out = [];\r\n                        for (var object of res[this.document]) {\r\n                            for (var key in object) {\r\n                                object[key] = JSON.parse(object[key]);\r\n                            }\r\n                            if (conditionOrField(object)) {\r\n                                out.push(object);\r\n                            }\r\n                        }\r\n                        resolve(out);\r\n                    }\r\n                    else {\r\n                        reject(`Error finding document ${this.document}`);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    }\r\n    all() {\r\n        return new Promise((resolve, reject) => {\r\n            chrome.storage.sync.get(this.document, (res) => {\r\n                if (res[this.document] != undefined) {\r\n                    for (var i = 0; i < res[this.document].length; i++) {\r\n                        var object = res[this.document][i];\r\n                        for (var key in object) {\r\n                            object[key] = JSON.parse(object[key]);\r\n                        }\r\n                        res[this.document][i] = object;\r\n                    }\r\n                    resolve(res[this.document]);\r\n                }\r\n                else {\r\n                    reject(`Error finding document ${this.document}`);\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\nclass Set {\r\n    constructor(document, values) {\r\n        this.document = document;\r\n        this.values = values;\r\n    }\r\n    where(conditionOrField) {\r\n        if (typeof conditionOrField === \"string\") {\r\n            return new FieldCondition(conditionOrField, this);\r\n        }\r\n        else {\r\n            return new Promise((resolve, reject) => {\r\n                chrome.storage.sync.get(this.document, (res) => {\r\n                    if (res[this.document] != undefined) {\r\n                        for (var i = 0; i < res[this.document].length; i++) {\r\n                            var object = res[this.document][i];\r\n                            for (var key in object) {\r\n                                object[key] = JSON.parse(object[key]);\r\n                            }\r\n                            if (conditionOrField(object)) {\r\n                                this.values.forEach((val, key) => {\r\n                                    res[this.document][i][key] = JSON.stringify(val);\r\n                                });\r\n                            }\r\n                        }\r\n                        chrome.storage.sync.set({ [this.document]: res }, () => {\r\n                            resolve(true);\r\n                        });\r\n                    }\r\n                    else {\r\n                        reject(`Error finding document ${this.document}`);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    }\r\n    //TODO: WASM\r\n    all() {\r\n        return new Promise((resolve, reject) => {\r\n            chrome.storage.sync.get(this.document, (res) => {\r\n                if (res[this.document] != undefined) {\r\n                    for (var i = 0; i < res[this.document].length; i++) {\r\n                        this.values.forEach((val, key) => {\r\n                            res[this.document][i][key] = JSON.stringify(val);\r\n                        });\r\n                    }\r\n                    chrome.storage.sync.set({ [this.document]: res }, () => {\r\n                        resolve(true);\r\n                    });\r\n                }\r\n                else {\r\n                    reject(`Error finding document ${this.document}`);\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\nclass Document {\r\n    constructor(name) {\r\n        this.name = name;\r\n    }\r\n    get() {\r\n        return new Get(this.name);\r\n    }\r\n    set(values) {\r\n        return new Set(this.name, values);\r\n    }\r\n    add(object) {\r\n        return new Promise((resolve, reject) => {\r\n            chrome.storage.sync.get(this.name, (res) => {\r\n                for (var key in object) {\r\n                    object[key] = JSON.stringify(object[key]);\r\n                }\r\n                if (res[this.name] != undefined) {\r\n                    res[this.name].push(object);\r\n                    chrome.storage.sync.set({ [this.name]: res[this.name] }, () => {\r\n                        resolve(true);\r\n                    });\r\n                }\r\n                else {\r\n                    reject(`Error finding document ${this.name}`);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    addAll(objects) {\r\n        return new Promise((resolve, reject) => {\r\n            chrome.storage.sync.get(this.name, (res) => {\r\n                for (var object of objects) {\r\n                    for (var key in object) {\r\n                        object[key] = JSON.stringify(object[key]);\r\n                    }\r\n                }\r\n                if (res[this.name] != undefined) {\r\n                    res[this.name].addAll(objects);\r\n                    chrome.storage.sync.set({ [this.name]: res }, () => {\r\n                        resolve(true);\r\n                    });\r\n                }\r\n                else {\r\n                    reject(`Error finding document ${this.name}`);\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\nclass ChromeDB {\r\n    static init(database) {\r\n        var db = new ChromeDB();\r\n        db.database = database;\r\n        return new Promise((resolve, reject) => {\r\n            chrome.storage.sync.get('chromedb_config', (res) => {\r\n                db.config = new Config();\r\n                if (res.chromedb_config != undefined) {\r\n                    db.config.documents = res.chromedb_config;\r\n                    if (!(database in db.config.documents)) {\r\n                        db.config.documents[database] = [];\r\n                    }\r\n                }\r\n                else {\r\n                    db.config.documents[database] = [];\r\n                }\r\n                resolve(db);\r\n            });\r\n        });\r\n    }\r\n    doc(name) {\r\n        if (this.config.documents[this.database].includes(name)) {\r\n            return new Document(name);\r\n        }\r\n        throw Error(`Document ${name} doesn't belong to database ${this.database}`);\r\n    }\r\n    makeDoc(name) {\r\n        if (this.config.documents[this.database].includes(name)) {\r\n            return new Promise((resolve, reject) => {\r\n                resolve(false);\r\n            });\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            chrome.storage.sync.set({ [name]: [] }, () => {\r\n                this.config.documents[this.database].push(name);\r\n                resolve(true);\r\n            });\r\n        });\r\n    }\r\n    deleteDoc(name) {\r\n        return new Promise((resolve, reject) => {\r\n            chrome.storage.sync.remove(name, () => {\r\n                this.config.documents[this.database].splice(this.config.documents[this.database].indexOf(name), 1);\r\n                resolve(true);\r\n            });\r\n        });\r\n    }\r\n}\r\nexports.ChromeDB = ChromeDB;\r\n//# sourceMappingURL=chromedb.js.map","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst chromedb_1 = require(\"./chromedb\");\r\nconst main = () => __awaiter(void 0, void 0, void 0, function* () {\r\n    let client = yield chromedb_1.ChromeDB.init(\"MyDB\");\r\n    yield client.makeDoc(\"MyDoc\");\r\n    yield client.doc(\"MyDoc\").add({ \"id\": 0, \"content\": \"hello\" });\r\n    var obj = yield client.doc(\"MyDoc\").get().where(\"id\").is(0);\r\n    console.log(obj);\r\n});\r\nmain();\r\n//# sourceMappingURL=main.js.map","// Runtime header offsets\nconst ID_OFFSET = -8;\nconst SIZE_OFFSET = -4;\n\n// Runtime ids\nconst ARRAYBUFFER_ID = 0;\nconst STRING_ID = 1;\n// const ARRAYBUFFERVIEW_ID = 2;\n\n// Runtime type information\nconst ARRAYBUFFERVIEW = 1 << 0;\nconst ARRAY = 1 << 1;\nconst STATICARRAY = 1 << 2;\n// const SET = 1 << 3;\n// const MAP = 1 << 4;\nconst VAL_ALIGN_OFFSET = 6;\n// const VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;\nconst VAL_SIGNED = 1 << 11;\nconst VAL_FLOAT = 1 << 12;\n// const VAL_NULLABLE = 1 << 13;\nconst VAL_MANAGED = 1 << 14;\n// const KEY_ALIGN_OFFSET = 15;\n// const KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;\n// const KEY_SIGNED = 1 << 20;\n// const KEY_FLOAT = 1 << 21;\n// const KEY_NULLABLE = 1 << 22;\n// const KEY_MANAGED = 1 << 23;\n\n// Array(BufferView) layout\nconst ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;\nconst ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;\nconst ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;\nconst ARRAYBUFFERVIEW_SIZE = 12;\nconst ARRAY_LENGTH_OFFSET = 12;\nconst ARRAY_SIZE = 16;\n\nconst BIGINT = typeof BigUint64Array !== \"undefined\";\nconst THIS = Symbol();\n\nconst STRING_DECODE_THRESHOLD = 32;\nconst decoder = new TextDecoder(\"utf-16le\");\n\n/** Gets a string from an U32 and an U16 view on a memory. */\nfunction getStringImpl(buffer, ptr) {\n  const len = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2] >>> 1;\n  const arr = new Uint16Array(buffer, ptr, len);\n  if (len <= STRING_DECODE_THRESHOLD) {\n    return String.fromCharCode.apply(String, arr);\n  }\n  return decoder.decode(arr);\n}\n\n/** Prepares the base module prior to instantiation. */\nfunction preInstantiate(imports) {\n  const extendedExports = {};\n\n  function getString(memory, ptr) {\n    if (!memory) return \"<yet unknown>\";\n    return getStringImpl(memory.buffer, ptr);\n  }\n\n  // add common imports used by stdlib for convenience\n  const env = (imports.env = imports.env || {});\n  env.abort = env.abort || function abort(msg, file, line, colm) {\n    const memory = extendedExports.memory || env.memory; // prefer exported, otherwise try imported\n    throw Error(`abort: ${getString(memory, msg)} at ${getString(memory, file)}:${line}:${colm}`);\n  };\n  env.trace = env.trace || function trace(msg, n, ...args) {\n    const memory = extendedExports.memory || env.memory;\n    console.log(`trace: ${getString(memory, msg)}${n ? \" \" : \"\"}${args.slice(0, n).join(\", \")}`);\n  };\n  env.seed = env.seed || Date.now;\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n\n  return extendedExports;\n}\n\nconst E_NOEXPORTRUNTIME = \"Operation requires compiling with --exportRuntime\";\nconst F_NOEXPORTRUNTIME = function() { throw Error(E_NOEXPORTRUNTIME); };\n\n/** Prepares the final module once instantiation is complete. */\nfunction postInstantiate(extendedExports, instance) {\n  const exports = instance.exports;\n  const memory = exports.memory;\n  const table = exports.table;\n  const __new = exports.__new || F_NOEXPORTRUNTIME;\n  const __pin = exports.__pin || F_NOEXPORTRUNTIME;\n  const __unpin = exports.__unpin || F_NOEXPORTRUNTIME;\n  const __collect = exports.__collect || F_NOEXPORTRUNTIME;\n  const __rtti_base = exports.__rtti_base || ~0; // oob if not present\n\n  extendedExports.__new = __new;\n  extendedExports.__pin = __pin;\n  extendedExports.__unpin = __unpin;\n  extendedExports.__collect = __collect;\n\n  /** Gets the runtime type info for the given id. */\n  function getInfo(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[__rtti_base >>> 2];\n    if ((id >>>= 0) >= count) throw Error(`invalid id: ${id}`);\n    return U32[(__rtti_base + 4 >>> 2) + id * 2];\n  }\n\n  /** Gets and validate runtime type info for the given id for array like objects */\n  function getArrayInfo(id) {\n    const info = getInfo(id);\n    if (!(info & (ARRAYBUFFERVIEW | ARRAY | STATICARRAY))) throw Error(`not an array: ${id}, flags=${info}`);\n    return info;\n  }\n\n  /** Gets the runtime base id for the given id. */\n  function getBase(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[__rtti_base >>> 2];\n    if ((id >>>= 0) >= count) throw Error(`invalid id: ${id}`);\n    return U32[(__rtti_base + 4 >>> 2) + id * 2 + 1];\n  }\n\n  /** Gets the runtime alignment of a collection's values. */\n  function getValueAlign(info) {\n    return 31 - Math.clz32((info >>> VAL_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Gets the runtime alignment of a collection's keys. */\n  // function getKeyAlign(info) {\n  //   return 31 - Math.clz32((info >>> KEY_ALIGN_OFFSET) & 31); // -1 if none\n  // }\n\n  /** Allocates a new string in the module's memory and returns its pointer. */\n  function __newString(str) {\n    if (str == null) return 0;\n    const length = str.length;\n    const ptr = __new(length << 1, STRING_ID);\n    const U16 = new Uint16Array(memory.buffer);\n    for (var i = 0, p = ptr >>> 1; i < length; ++i) U16[p + i] = str.charCodeAt(i);\n    return ptr;\n  }\n\n  extendedExports.__newString = __newString;\n\n  /** Reads a string from the module's memory by its pointer. */\n  function __getString(ptr) {\n    if (!ptr) return null;\n    const buffer = memory.buffer;\n    const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];\n    if (id !== STRING_ID) throw Error(`not a string: ${ptr}`);\n    return getStringImpl(buffer, ptr);\n  }\n\n  extendedExports.__getString = __getString;\n\n  /** Gets the view matching the specified alignment, signedness and floatness. */\n  function getView(alignLog2, signed, float) {\n    const buffer = memory.buffer;\n    if (float) {\n      switch (alignLog2) {\n        case 2: return new Float32Array(buffer);\n        case 3: return new Float64Array(buffer);\n      }\n    } else {\n      switch (alignLog2) {\n        case 0: return new (signed ? Int8Array : Uint8Array)(buffer);\n        case 1: return new (signed ? Int16Array : Uint16Array)(buffer);\n        case 2: return new (signed ? Int32Array : Uint32Array)(buffer);\n        case 3: return new (signed ? BigInt64Array : BigUint64Array)(buffer);\n      }\n    }\n    throw Error(`unsupported align: ${alignLog2}`);\n  }\n\n  /** Allocates a new array in the module's memory and returns its pointer. */\n  function __newArray(id, values) {\n    const info = getArrayInfo(id);\n    const align = getValueAlign(info);\n    const length = values.length;\n    const buf = __new(length << align, info & STATICARRAY ? id : ARRAYBUFFER_ID);\n    let result;\n    if (info & STATICARRAY) {\n      result = buf;\n    } else {\n      __pin(buf);\n      const arr = __new(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);\n      __unpin(buf);\n      const U32 = new Uint32Array(memory.buffer);\n      U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = buf;\n      U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;\n      U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;\n      if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;\n      result = arr;\n    }\n    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);\n    if (info & VAL_MANAGED) {\n      for (let i = 0; i < length; ++i) {\n        const value = values[i];\n        view[(buf >>> align) + i] = value;\n      }\n    } else {\n      view.set(values, buf >>> align);\n    }\n    return result;\n  }\n\n  extendedExports.__newArray = __newArray;\n\n  /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */\n  function __getArrayView(arr) {\n    const U32 = new Uint32Array(memory.buffer);\n    const id = U32[arr + ID_OFFSET >>> 2];\n    const info = getArrayInfo(id);\n    const align = getValueAlign(info);\n    let buf = info & STATICARRAY\n      ? arr\n      : U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    const length = info & ARRAY\n      ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2]\n      : U32[buf + SIZE_OFFSET >>> 2] >>> align;\n    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf >>>= align, buf + length);\n  }\n\n  extendedExports.__getArrayView = __getArrayView;\n\n  /** Copies an array's values from the module's memory. Infers the array type from RTTI. */\n  function __getArray(arr) {\n    const input = __getArrayView(arr);\n    const len = input.length;\n    const out = new Array(len);\n    for (let i = 0; i < len; i++) out[i] = input[i];\n    return out;\n  }\n\n  extendedExports.__getArray = __getArray;\n\n  /** Copies an ArrayBuffer's value from the module's memory. */\n  function __getArrayBuffer(ptr) {\n    const buffer = memory.buffer;\n    const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];\n    return buffer.slice(ptr, ptr + length);\n  }\n\n  extendedExports.__getArrayBuffer = __getArrayBuffer;\n\n  /** Copies a typed array's values from the module's memory. */\n  function getTypedArray(Type, alignLog2, ptr) {\n    return new Type(getTypedArrayView(Type, alignLog2, ptr));\n  }\n\n  /** Gets a live view on a typed array's values in the module's memory. */\n  function getTypedArrayView(Type, alignLog2, ptr) {\n    const buffer = memory.buffer;\n    const U32 = new Uint32Array(buffer);\n    const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);\n  }\n\n  /** Attach a set of get TypedArray and View functions to the exports. */\n  function attachTypedArrayFunctions(ctor, name, align) {\n    extendedExports[`__get${name}`] = getTypedArray.bind(null, ctor, align);\n    extendedExports[`__get${name}View`] = getTypedArrayView.bind(null, ctor, align);\n  }\n\n  [\n    Int8Array,\n    Uint8Array,\n    Uint8ClampedArray,\n    Int16Array,\n    Uint16Array,\n    Int32Array,\n    Uint32Array,\n    Float32Array,\n    Float64Array\n  ].forEach(ctor => {\n    attachTypedArrayFunctions(ctor, ctor.name, 31 - Math.clz32(ctor.BYTES_PER_ELEMENT));\n  });\n\n  if (BIGINT) {\n    [BigUint64Array, BigInt64Array].forEach(ctor => {\n      attachTypedArrayFunctions(ctor, ctor.name.slice(3), 3);\n    });\n  }\n\n  /** Tests whether an object is an instance of the class represented by the specified base id. */\n  function __instanceof(ptr, baseId) {\n    const U32 = new Uint32Array(memory.buffer);\n    let id = U32[ptr + ID_OFFSET >>> 2];\n    if (id <= U32[__rtti_base >>> 2]) {\n      do {\n        if (id == baseId) return true;\n        id = getBase(id);\n      } while (id);\n    }\n    return false;\n  }\n\n  extendedExports.__instanceof = __instanceof;\n\n  // Pull basic exports to extendedExports so code in preInstantiate can use them\n  extendedExports.memory = extendedExports.memory || memory;\n  extendedExports.table  = extendedExports.table  || table;\n\n  // Demangle exports and provide the usual utility on the prototype\n  return demangle(exports, extendedExports);\n}\n\nfunction isResponse(src) {\n  return typeof Response !== \"undefined\" && src instanceof Response;\n}\n\nfunction isModule(src) {\n  return src instanceof WebAssembly.Module;\n}\n\n/** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */\nexport async function instantiate(source, imports = {}) {\n  if (isResponse(source = await source)) return instantiateStreaming(source, imports);\n  const module = isModule(source) ? source : await WebAssembly.compile(source);\n  const extended = preInstantiate(imports);\n  const instance = await WebAssembly.instantiate(module, imports);\n  const exports = postInstantiate(extended, instance);\n  return { module, instance, exports };\n}\n\n/** Synchronously instantiates an AssemblyScript module from a WebAssembly.Module or binary buffer. */\nexport function instantiateSync(source, imports = {}) {\n  const module = isModule(source) ? source : new WebAssembly.Module(source);\n  const extended = preInstantiate(imports);\n  const instance = new WebAssembly.Instance(module, imports);\n  const exports = postInstantiate(extended, instance);\n  return { module, instance, exports };\n}\n\n/** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */\nexport async function instantiateStreaming(source, imports = {}) {\n  if (!WebAssembly.instantiateStreaming) {\n    return instantiate(\n      isResponse(source = await source)\n        ? source.arrayBuffer()\n        : source,\n      imports\n    );\n  }\n  const extended = preInstantiate(imports);\n  const result = await WebAssembly.instantiateStreaming(source, imports);\n  const exports = postInstantiate(extended, result.instance);\n  return { ...result, exports };\n}\n\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\nexport function demangle(exports, extendedExports = {}) {\n  const setArgumentsLength = exports[\"__argumentsLength\"]\n    ? length => { exports[\"__argumentsLength\"].value = length; }\n    : exports[\"__setArgumentsLength\"] || exports[\"__setargc\"] || (() => { /* nop */ });\n  for (let internalName in exports) {\n    if (!Object.prototype.hasOwnProperty.call(exports, internalName)) continue;\n    const elem = exports[internalName];\n    let parts = internalName.split(\".\");\n    let curr = extendedExports;\n    while (parts.length > 1) {\n      let part = parts.shift();\n      if (!Object.prototype.hasOwnProperty.call(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n    let name = parts[0];\n    let hash = name.indexOf(\"#\");\n    if (hash >= 0) {\n      const className = name.substring(0, hash);\n      const classElem = curr[className];\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        const ctor = function(...args) {\n          return ctor.wrap(ctor.prototype.constructor(0, ...args));\n        };\n        ctor.prototype = {\n          valueOf() { return this[THIS]; }\n        };\n        ctor.wrap = function(thisValue) {\n          return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });\n        };\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>\n          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))\n        );\n        curr[className] = ctor;\n      }\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          let getter = exports[internalName.replace(\"set:\", \"get:\")];\n          let setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get() { return getter(this[THIS]); },\n            set(value) { setter(this[THIS], value); },\n            enumerable: true\n          });\n        }\n      } else {\n        if (name === 'constructor') {\n          (curr[name] = (...args) => {\n            setArgumentsLength(args.length);\n            return elem(...args);\n          }).original = elem;\n        } else { // instance method\n          (curr[name] = function(...args) { // !\n            setArgumentsLength(args.length);\n            return elem(this[THIS], ...args);\n          }).original = elem;\n        }\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\" && elem !== setArgumentsLength) {\n        (curr[name] = (...args) => {\n          setArgumentsLength(args.length);\n          return elem(...args);\n        }).original = elem;\n      } else {\n        curr[name] = elem;\n      }\n    }\n  }\n  return extendedExports;\n}\n\nexport default {\n  instantiate,\n  instantiateSync,\n  instantiateStreaming,\n  demangle\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./js/ts/main.js\");\n"],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;AClaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;ACrbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;;;A","sourceRoot":""}